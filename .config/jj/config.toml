"$schema" = "https://jj-vcs.github.io/jj/latest/config-schema.json"

[ui]
default-command = ["log", "--limit", "10"]
diff-editor = ["nvim", "-c", "DiffEditor $left $right $output"]
pager = "delta"
diff-formatter = ":git"

[user]
name = "saltor"
email = "storcivia@fastgrowingtrees.com"

[defaults]
log.limit = 20

[merge-tools.diffconflicts]
program = "nvim"
merge-args = ["-c", "JJDiffConflicts", "$output"]
merge-tool-edits-conflict-markers = true

[aliases]
# Pull the closest bookmark to where the working copy is
tug = ["bookmark", "move", "--from", "closest_bookmark(@)", "--to", "closest_pushable(@)"]

# 'jj sandwich xyz' to move xyz into the megamerge in parallel to everything
# else. See notes on 'megamerge()' above for how it's resolved.
sandwich = [ "rebase", "-B", "megamerge()", "-A", "trunk()", "-r"]

# Log everything between here and where we forked from trunk
current = ["log", "-r", "trunk()::heads(bookmarks() & @::)"]

# Get all open stacks of work
open = ["log", "-r", "open()"]

# Retrunk the current stack of work.
reheat = ["rebase", "-d", "trunk()", "-s", "roots(trunk()..stack(@))"]

# "Back" button for the working directory: go back to (edit) the last (or Nth
# last) change that @ was editing, in op log order.
#
# Usage: jj back [N]
back = ["util", "exec", "--", "bash", "-c", """
    if [[ $# -gt 0 ]]; then N=$1; shift; else N=1; fi
    resolve () { jj log --no-graph -r@ -T'change_id.short() ++ "\\n"' "$@"; }
    current=$(resolve)
    jj op log --no-graph -T 'id.short() ++ "\\n"' | while read op; do
        old=$(resolve --at-op $op)
        if [[ $old != $current ]]; then
            echo -n "$N      \r"
            N=$(( $N - 1 ))
            if [[ $N -eq 0 ]]; then
                echo -n "        \r"
                if ! jj edit $old 2>/dev/null; then
                    # Handle temporary problem with evolution moving to the op log.
                    old_commit="$(jj evolog -r $old --at-op $op --no-graph -n1 -T 'commit_id.short() ++ ":"')"
                    old_commit="${old_commit%%:*}"
                    echo "$old not found, trying commit $old_commit"
                    jj edit $old_commit
                fi
                exit 0
            fi
            current="$old"
        fi
    done
""", "jj-back"]

[revsets]
log = "stack(mine() | @) | trunk() | @"

[revset-aliases]
"immutable_heads()" = "builtin_immutable_heads()"
"why_immutable(r)" = "r | roots(r:: & immutable_heads())"
"closest_bookmark(to)" = "heads(::to & bookmarks())"
"closest_pushable(to)" = "heads(::to & mutable() & ~description(exact:'') & (~empty() | merges()))"
"chunk(x)" = "heads(::x- & bookmarks())..roots(x:: & bookmarks())"

"recent_work" = "ancestors(visible_heads(), 3) & mutable()"
"user(x)" = "author(x) | committer(x)"

"mine()" = 'user("storcivia@fastgrowingtrees.com") | user("github+0019@saltor.nyc")'

"wip()" = "description(glob-i:'wip:*') | description(glob-i:'[[]WIP[]]*')"
"private()" = "description(glob-i:'private:*') | description(glob-i:'[[]PRIVATE[]]*')"
"blacklist()" = "wip() | private()"

# stack(x, n) is the set of mutable commits reachable from 'x', with 'n'
# parents. 'n' is often useful to customize the display and return set for
# certain operations. 'x' can be used to target the set of 'roots' to traverse,
# e.g. @ is the current stack.
"stack()" = 'stack(@)'
"stack(x)" = 'stack(x, 2)'
"stack(x, n)" = "ancestors(reachable(x, mutable()), n)"

# The current set of "open" works. It is defined as: all stacks that are
# reachable from my working copy, or any other commit I wrote.
# n = 1, meaning that nothing from `trunk()` is included, so all resulting
# commits are mutable by definition.
"open()" = "stack(mine() | @, 1)"

# Find the megamerge. Mostly useful in combination with other aliases, primarily
# 'sandwich'. Normally when there's only one megamerge, sandwich works perfectly
# fine and is basically "magic". However, there are more complex cases; consider
# something like this which represents a forked repository of an upstream:
#
#
#    ----> P1 ... Pn -----------\
#   /                            \
#  /---> X --\           (main)   \
# B          M1 --> T1 ... Tn --> M2 --> @
#  \---> Y --/
#
# X and Y are typical features on top of base B, combined inside megamerge M1.
# However, we may want changes T1...Tn to go on top of M1, because (in my case)
# they're custom and will never go upstream, but are correctly published as part
# of the fork; Tn is where the main bookmark points. Finally, we have changes P1
# ... Pn which are private and should never be pushed upstream at all.
#
# In this case, sandwich will work poorly because 'reachable(stack(), merges())'
# will resolve to {M1, M2}, which is not what we want for 'rebase -B'. So to
# handle that case, we allow the user to specify the merge via literal tag
# "megamerge". In this case if we 'bookmark set megamerge -r M1' then sandwich
# will always work correctly.
'megamerge()' = 'coalesce(present(megamerge), reachable(stack(), merges()))'

[template-aliases]
"format_short_signature(signature)" = '''
coalesce(signature.name(), signature.email(), 'unknown')
'''
