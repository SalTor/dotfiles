#+title: My emacs configuration via org mode!
#+author: Me. Your friendly neighborhood web developer

* Base layer
** Package management tooling
** Miscellaneous Settings
*** Namespacing
#+begin_src emacs-lisp
  (add-to-list 'load-path  "~/dotfiles/emacs/modules")
  (add-to-list 'load-path  "~/dotfiles/emacs/project-setups")
#+end_src
*** Garbage collection
#+begin_src emacs-lisp
  ;; The rest of the init file.

  ;; Make gc pauses faster by decreasing the threshold.
  ;; (setq gc-cons-threshold (* 2 1000 1000))

  ;; The default is 800 kilobytes.  Measured in bytes.
  ;; (setq gc-cons-percentage 0.6)
  ;; (setq gc-cons-threshold most-positive-fixnum)

  (defun display-startup-time ()
      "Display startup time."
      (message "Emacs loaded in %s with %d garbage collections."
              (format "%.2f seconds"
                      (float-time
                      (time-subtract after-init-time before-init-time)))
              gcs-done))

  (add-hook 'emacs-startup-hook #'display-startup-time)
#+end_src
*** Basic settings
#+begin_src emacs-lisp
  (setq create-lockfiles nil)
  (setq auto-save-default nil)

  (setq backup-directory-alist '(("." . "~/.config/emacs/.saves")))

  (setq inhibit-startup-message t)

  (defalias 'yes-or-no-p #'y-or-n-p)

  (setq-default indent-tabs-mode nil)
  (setq-default tab-always-indent t)
  (setq-default indent-line-function 'insert-tab)

  (set-face-attribute 'default nil :font "Source Code Pro" :height 130)

  (save-place-mode 1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)

  (column-number-mode)

  (show-paren-mode 1)
  (electric-pair-mode 1)

  ;; Suppress warnings about cl being deprecated
  (setq byte-compile-warnings '(cl-functions))

  (use-package posframe)
#+end_src
*** Modeline changes
#+begin_src emacs-lisp
  (use-package minions
    :config (minions-mode))
#+end_src
*** Theme
#+begin_src emacs-lisp
  ;; (use-package doom-themes
  ;;   :init
  ;;   (setq doom-themes-treemacs-theme "doom-colors")
  ;;   :config
  ;;   (load-theme 'doom-gruvbox t)
  ;;   (doom-themes-visual-bell-config))
  (load-theme 'modus-operandi)
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs nil
        modus-themes-mixed-fonts nil
        modus-themes-tabs-accented t
        modus-themes-variable-pitch-ui nil
        modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related
        modus-themes-fringes nil ; {nil, 'subtle, 'intense}
        modus-themes-success-deuteranopia t
        )
#+end_src
*** Line number settings
#+begin_src emacs-lisp
  (global-hl-line-mode 1)

  (defun sal-enable-linum ()
    (interactive)
    (if (eq nil display-line-numbers)
        (setq display-line-numbers 'absolute)
      (message "Linum mode set")))

  (add-hook 'prog-mode-hook 'sal-enable-linum)

  (global-linum-mode -1)

  (setq display-line-numbers 'absolute)
#+end_src
*** Whitespace management
#+begin_src emacs-lisp
  (whitespace-mode)
  (use-package whitespace-cleanup-mode
    :config
    (global-whitespace-cleanup-mode))
#+end_src
** Keybindings with general.el
More convenient key definitions in emacs
#+begin_src emacs-lisp
  (defun sal-switch-linum-mode ()
    (interactive)
    (if (eq 'relative display-line-numbers)
        (setq display-line-numbers 'absolute)
      (setq display-line-numbers 'relative)))

  (use-package general
    :config
    (general-create-definer leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC")
    ;; Toggles
    (leader-keys
      "T"  '(:ignore t :which-key "toggles")
      "Tn" '(sal-switch-linum-mode :which-key "change linum mode")))

  (defun sal-switch-linum-mode ()
    (interactive)
    (if (eq 'relative display-line-numbers)
        (setq display-line-numbers 'absolute)
      (setq display-line-numbers 'relative)))
#+end_src
** Helpful to improve help docs
An alternative to the built-in Emacs help that provides much more contextual information
#+begin_src emacs-lisp
  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key))

  ;; Note that the built-in `describe-function' includes both functions
  ;; and macros. `helpful-function' is functions only, so we provide
  ;; `helpful-callable' as a drop-in replacement.
  (global-set-key (kbd "C-h f") #'helpful-callable)

  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)

  (leader-keys
    "h" 'help-command)
#+end_src
** EVIL (Emacs VIm Layer--A++ vim emulator)
*** Pre-reqs for other utilities
There's multiple ways to achieve an undo tree and code folding, undo-fu is for the former and origami for the latter
#+begin_src emacs-lisp
  (use-package undo-fu :config (global-undo-tree-mode -1))
  (use-package origami :config (global-origami-mode))
  (use-package drag-stuff :config (drag-stuff-mode t))
#+end_src
*** The evil package
#+begin_src emacs-lisp
  (general-evil-setup t)

  (use-package evil
    :init
    (setq evil-want-keybinding nil)
    (setq-default evil-symbol-word-search t)
    (add-hook 'evil-local-mode-hook 'turn-on-undo-tree-mode)
    :custom
    (evil-want-C-u-scroll t)
    (evil-want-C-i-jump nil)
    (evil-want-Y-yank-to-eol t)
    (evil-undo-system 'undo-fu)
    :config
    (evil-set-initial-state 'Custom-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal)
    (evil-mode 1))
#+end_src

And some bindings for vim modes
#+begin_src emacs-lisp
  (defun insert-line-below ()
    "Insert an empty line below the current line."
    (interactive)
    (save-excursion
      (end-of-line)
      (open-line 1)))

  (defun insert-line-above ()
    "Insert an empty line above the current line."
    (interactive)
    (save-excursion
      (end-of-line 0)
      (open-line 1)))

  (general-define-key
   :states '(normal)
   "u" 'undo-fu-only-undo
   "U" 'undo-fu-only-redo
   "\C-r" 'undo-fu-only-redo
   "gm" 'evil-search-word-forward
   "gl" 'evil-end-of-line
   "gh" 'evil-beginning-of-line
   )

  (define-key evil-normal-state-map (kbd "[ SPC") 'insert-line-above)
  (define-key evil-normal-state-map (kbd "] SPC") 'insert-line-below)

  (general-define-key
   :states '(visual)
   "J" 'drag-stuff-down
   "K" 'drag-stuff-up
   )

  ;; (general-translate-key nil 'motion
  ;;   "ESC" "C-g")

  (define-key key-translation-map (kbd "ESC") (kbd "C-g"))
#+end_src
*** Evil Collection
A set of keybindings for evil-mode
#+begin_src emacs-lisp
  (setq evil-want-keybinding nil)

  (use-package evil-collection
    (evil-collection-want-unimpaired-p nil)
    )

  (evil-collection-init)
#+end_src
*** Evil leader
<leader> key for evil-mode
#+begin_src emacs-lisp
  (use-package evil-leader
    :config (global-evil-leader-mode))

  ;; I use the spacebar as my leader key
  (evil-leader/set-leader "SPC")

  ;; Some basic quit and comment out
  (leader-keys "qq" 'save-buffers-kill-terminal)
  (leader-keys "cc" 'comment-line)
#+end_src
I use <C-u> for scroll up, but default emacs uses that for something called "universal-argument" so I add this bindign for backwards compatibility
Emacs uses <M-x> (aka alt-x) for running commands (somewhat similar to vim's command mode accessed via ":") but I find <SPC-x> easier to access
#+begin_src emacs-lisp
  (leader-keys
    "u" 'universal-argument
    "x" 'execute-extended-command)
#+end_src
*** Evil surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :config (global-evil-surround-mode 1))
#+end_src
*** Evil goggles
For highlighting certain code actions. I like seeing what I yanked to my clipboard with a simple and quick flash of colored text
#+begin_src emacs-lisp
  (use-package evil-goggles
    :config
    (evil-goggles-mode)
    (setq evil-goggles-duration 0.500
          evil-goggles-blocking-duration 0.001
          evil-goggles-async-duration 0.900
          evil-goggles-enable-paste nil
          evil-goggles-enable-delete nil
          evil-goggles-enable-change nil
          evil-goggles-enable-indent nil
          evil-goggles-enable-join nil
          evil-goggles-enable-fill-and-move nil
          evil-goggles-enable-paste nil
          evil-goggles-enable-shift nil
          evil-goggles-enable-surround nil
          evil-goggles-enable-commentary nil
          evil-goggles-enable-nerd-commenter nil
          evil-goggles-enable-replace-with-register nil
          evil-goggles-enable-set-marker nil
          evil-goggles-enable-undo nil
          evil-goggles-enable-redo nil
          evil-goggles-enable-record-macro nil))
#+end_src
*** Evil nerd commenter
Simple package for commenting out code
#+begin_src emacs-lisp
  (use-package evil-nerd-commenter)
#+end_src
** Hydra
#+begin_src emacs-lisp
  (use-package hydra)
#+end_src
*** Font size Hydra
#+begin_src emacs-lisp
  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

  (leader-keys
    "tf" '(hydra-text-scale/body :which-key "scale text"))
#+end_src
*** Scrolling Hydra
#+begin_src emacs-lisp
  (defhydra hydra-scroll-page (:timeout 4)
    "scroll the page"
    ("k" evil-scroll-up "up")
    ("j" evil-scroll-down "down")
    ("f" nil "finished" :exit t))

  (leader-keys
    "ts" '(hydra-scroll-page/body :which-key "scroll page"))
#+end_src
** Whichkey
#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src
* Miscellaneous
** Consult
#+begin_src emacs-lisp
  (use-package consult
    :config
    (setq consult-preview-key (kbd "C-\\")))
#+end_src
** straight.el
#+begin_src emacs-lisp
(straight-use-package 'use-package)
#+end_src
** Selectrum
#+begin_src emacs-lisp
  (use-package selectrum
    :config
    (selectrum-mode +1)
    :bind (:map selectrum-minibuffer-map
                ("C-j" . selectrum-next-candidate)
                ("C-k" . selectrum-previous-candidate)))

  (use-package selectrum-prescient
    :config
    ;; to make sorting and filtering more intelligent
    (selectrum-prescient-mode +1)

    ;; to save your command history on disk, so the sorting gets more
    ;; intelligent over time
    (prescient-persist-mode +1))

  ;; (use-package hotfuzz
    ;; :straight (hotfuzz :type git :host github :repo "axelf4/hotfuzz")
    ;; :config
    ;; (setq pcomplete-ignore-case t)
    ;; (setq completion-ignore-case t)
    ;; (setq read-buffer-completion-ignore-case t)
    ;; (setq read-file-name-completion-ignore-case t)
    ;; (setq completion-styles '(hotfuzz))
    ;; (hotfuzz-selectrum-mode))
#+end_src
*** Marginalia
#+begin_src emacs-lisp
(use-package marginalia
  :after evil
  :config
  (add-to-list 'marginalia-prompt-categories '("Find file" . file))
  (marginalia-mode))
#+end_src
*** Embark
#+begin_src emacs-lisp
  (defun sal-split-right ()
    (interactive)
    (projectile--find-file (selectrum-get-current-candidate))
    (split-window-horizontally)
    (evil-switch-to-windows-last-buffer)
    (other-window 1))

  (defun sal-split-below ()
    (interactive)
    (projectile--find-file (selectrum-get-current-candidate))
    (split-window-below)
    (evil-switch-to-windows-last-buffer)
    (other-window 1))

  (use-package embark
    :bind (("C-." . embark-act))
    :config
    (embark-define-keymap sal-embark-file-map
      "Keymap for actions for tab-bar tabs (when mentioned by name)."
      ("-" sal-split-below)
      ("/" sal-split-right))
    (add-to-list 'embark-keymap-alist '(file . sal-embark-file-map))

    (setq embark-action-indicator
          (lambda (map _target)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator)
    )
#+end_src
*** Ripgrep
#+begin_src emacs-lisp
  (use-package ripgrep)
  (use-package deadgrep)
#+end_src
** Company mode
#+begin_src emacs-lisp
  (use-package company
    :config
    (company-tng-mode)
    (setq company-minimum-prefix-length 1)
    (setq company-tooltip-align-annotations t)
    (setq company-selection-wrap-around t))

  (add-hook 'after-init-hook 'global-company-mode)

  ;; Nice icons in company dropdowns
  (use-package company-box
    :hook (company-mode . company-box-mode))

  (use-package pos-tip)

  ;; Add overlay documentation for the options company provides
  (use-package company-quickhelp
    :config (company-quickhelp-mode))

  (eval-after-load 'company '(define-key company-active-map (kbd "C-c h") #'company-quickhelp-manual-begin))
#+end_src
** Dashboard: recentf / bookmarks / MRU
#+begin_src emacs-lisp
  (use-package dashboard
    :config
    (setq dashboard-set-heading-icons t
          dashboard-startup-banner 'logo
          dashboard-center-content nil
          dashboard-set-navigator t
          dashboard-set-file-icons t)
    (setq dashboard-items '((recents  . 10)
                            (bookmarks . 5)
                            (projects . 5)))
    (dashboard-setup-startup-hook))
#+end_src
** Org mode
#+begin_src emacs-lisp
  (defun sal/org-mode-setup ()
    "Org mode setup."
    (global-linum-mode 0))

  (use-package org
    :defer 1
    :bind
    (:map org-mode-map
          ("C-c e" . org-edit-special))
    (:map org-src-mode-map
          ("C-c s" . org-edit-src-exit))
    :hook ((org-mode . sal/org-mode-setup)
           (org-mode . visual-line-mode)
           (org-mode . org-indent-mode)
           (org-mode . (lambda () (setq-local evil-auto-indent nil))))
    :config
    (setq org-return-follows-link t)
    (setq org-ellipsis " ▾")
    :custom
    (org-hide-emphasis-markers t))

  (use-package deft
    :after org
    :config
    (leader-keys
      "od" 'deft)
    :custom
    (deft-recursive t)
    (deft-use-filter-string-for-filename t)
    (deft-default-extension "org")
    (deft-directory "~/org-roam/"))

  (use-package org-roam
    :after (org evil)
    :config
    (leader-keys
      "or" 'org-roam
      "of" 'org-roam-find-file
      "oc" 'org-roam-capture
      "oi" 'org-roam-insert
      "oat" 'org-roam-tag-add)
    (setq org-roam-directory "~/org-roam")
    :init
    (org-roam-mode))
#+end_src

* Terminal settings
** exec-path-from-shell
Make Emacs use the $PATH set up by the user's shell
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (setenv "SHELL" "/bin/zsh")
    (setq shell-file-name "/bin/zsh"))
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize))
#+end_src
** VTerm
#+begin_src emacs-lisp
  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000)
    :hook
    (vterm-mode . (lambda ()
                    (setq-local hl-line-mode nil)
                    (setq-local line-number-mode nil)
                    (setq-local column-number-mode nil))))

  (use-package multi-vterm
    :config
    (define-key vterm-mode-map [return] #'vterm-send-return)

    (setq vterm-keymap-exceptions nil)
    (general-define-key
     :states '(insert)
     :keymaps 'vterm-mode-map
     "C-e" 'vterm--self-insert
     "C-f" 'vterm--self-insert
     "C-a" 'vterm--self-insert
     "C-v" 'vterm--self-insert
     "C-b" 'vterm--self-insert
     "C-w" 'vterm--self-insert
     "C-u" 'vterm--self-insert
     "C-n" 'vterm--self-insert
     "C-m" 'vterm--self-insert
     "C-p" 'vterm--self-insert
     "C-j" 'vterm--self-insert
     "C-k" 'vterm--self-insert
     "C-r" 'vterm--self-insert
     "C-t" 'vterm--self-insert
     "C-g" 'vterm--self-insert
     "C-c" 'vterm--self-insert
     "C-SPC" 'vterm--self-insert

     "C-d" #'evil-normal-state
     )

    (general-define-key
     :states '(normal)
     :keymaps 'vterm-mode-map
     ",c"        'multi-vterm-prev
     "i"         'evil-insert-resume
     "<return>"  'evil-insert-resume
     "<prior>" 'scroll-down-command
     "<next>" 'scroll-up-command

     "C-d"       #'evil-scroll-down
     )
    )

  (use-package eterm-256color
    :hook (vterm-mode . eterm-256color-mode))

  (use-package rainbow-mode
    :config
    (rainbow-mode))

  (use-package ivy)

  (defun sal-cd-project-root ()
    (if (projectile-project-root)
        (cd (projectile-project-root))))

  ;; Terminal
  (leader-keys
    "t" '(:ignore t :which-key "terminal")
    "tt" (lambda ()
           (interactive)
           (sal-cd-project-root)
           (multi-vterm))
    "t/" (lambda ()
           (interactive)
           (split-window-right)
           (other-window 1)
           (sal-cd-project-root)
           (multi-vterm))
    "td" (lambda ()
           (interactive)
           (split-window-below)
           (other-window 1)
           (sal-cd-project-root)
           (multi-vterm)))
#+end_src
* Project/file management
** Magit
#+begin_src emacs-lisp
  ;; Set so modeline info updates
  (setq auto-revert-check-vc-info t)

  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    :config
    (general-define-key
     :keymaps 'magit-status-mode-map
     "C-j" 'magit-section-forward
     "C-k" 'magit-section-backward
     "M-j" 'magit-section-forward-sibling
     "M-k" 'magit-section-backward-sibling
     "," 'projectile-find-file
     ";" 'switch-to-buffer
     "p" 'magit-pull)
    (setq magit-refresh-status-buffer nil)

    (defun kill-magit-diff-buffer-in-current-repo (&rest _)
      "Delete the magit-diff buffer related to the current repo"
      (let ((magit-diff-buffer-in-current-repo
             (magit-mode-get-buffer 'magit-diff-mode)))
        (kill-buffer magit-diff-buffer-in-current-repo)))
    ;; When 'C-c C-c' is pressed in the magit commit message buffer,
    ;;   delete the magit-diff buffer related to the current repo.
    (add-hook 'git-commit-setup-hook
              (lambda ()
                (add-hook 'with-editor-post-finish-hook
                          #'kill-magit-diff-buffer-in-current-repo
                          nil t))) ; the t is important
    )

  (leader-keys
    "gs" 'magit-status)
#+end_src
** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
    (projectile-mode))

  (leader-keys
    "," 'projectile-find-file
    "po" 'projectile-switch-project)
#+end_src
** Dired
#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :config
    (setq dired-dwim-target t)
    (evil-collection-define-key 'normal 'dired-mode-map
      "c" 'find-file
      "h" 'dired-up-directory
      "l" 'dired-find-file
      )
    (let ((gls "/usr/local/bin/gls"))
      (if (file-exists-p gls) (setq insert-directory-program gls)))
    )

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-open
    :commands
    (dired dired-jump)
    :config
    (setq dired-open-extensions '(("png" . "feh")
                                  ("mkv" . "mpv"))))
#+end_src
** Neotree
#+begin_src emacs-lisp
  (use-package neotree
    :defer 3
    :config
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow)
          neo-hide-cursor t
          neo-window-width 30)
    :general
    (:states 'normal
             :keymaps 'neotree-mode-map
             "md" 'neotree-delete-node
             "ma" 'neotree-create-node
             "mm" 'neotree-rename-node
             "R" 'neotree-refresh
             "RET" 'neotree-enter
             "s" 'avy-goto-word-1
             "H" 'neotree-hidden-file-toggle
             "?" 'describe-mode
             "h" 'neotree-select-up-node
             "l" 'neotree-enter
             "q" 'neotree-hide))
#+end_src
** Fzf
#+begin_src emacs-lisp
  (use-package fzf)

  ;; (defun fzf-find-file (&optional directory)
  ;;   (interactive)
  ;;   (let ((d (fzf/resolve-directory directory)))
  ;;     (fzf
  ;;     (lambda (x)
  ;;         (let ((f (expand-file-name x d)))
  ;;         (when (file-exists-p f)
  ;;             (find-file f))))
  ;;     d)))
#+end_src
** Custom commands
#+begin_src emacs-lisp
  (leader-keys
    "pc" 'capsule-cw-mfe)
#+end_src
** Config

#+begin_src emacs-lisp
  (leader-keys
    "sp" 'deadgrep)

  (defun show-file-name ()
    "Show the full path file name in the minibuffer."
    (interactive)
    (message (buffer-file-name))
    (kill-new (file-truename buffer-file-name)))

  (leader-keys
    "fe" 'neotree-projectile-action
    "fj" 'dired-jump
    "fr" 'rename-file
    "f5" 'load-file
    "fs" 'evil-write-all
    "fy" 'show-file-name
    "f.s" 'save-buffer)
#+end_src
* Buffer management
** Ibuffer
#+begin_src emacs-lisp
  (use-package ibuffer-projectile)
  (add-hook 'ibuffer-hook
      (lambda ()
        (ibuffer-projectile-set-filter-groups)))

  (defun ibuffer-jump-to-last-buffer ()
    (ibuffer-jump-to-buffer (buffer-name (cadr (buffer-list)))))

  (add-hook 'ibuffer-hook #'ibuffer-jump-to-last-buffer)
#+end_src
** Perspective.el
This allows us to group buffers and window layouts into different
virtual "workspaces". This is particularly useful when working with
multiple projects and you don't want to clutter your buffer list
#+begin_src emacs-lisp
  (use-package perspective
    :commands persp-state-load
    :custom
    (persp-state-default-file "~/Documents/perspective-saves")
    :init
    (persp-mode))

  (leader-keys
    "s;" 'persp-switch
    "s/" 'persp-switch
    "ss" 'persp-set-buffer
    "sr" 'persp-rename)
#+end_src
** Config
#+begin_src emacs-lisp
  (global-set-key (kbd "C-;") 'ibuffer)
  (global-set-key (kbd "C-/") 'ibuffer)

  (leader-keys
    ";" 'switch-to-buffer
    "/" 'switch-to-buffer
    "TAB" 'evil-switch-to-windows-last-buffer
    "br" 'rename-buffer
    "bd" 'kill-this-buffer)
#+end_src
* Window management
** winner-mode
#+begin_src emacs-lisp
  (winner-mode +1)
  (define-key winner-mode-map (kbd "<M-left>") #'winner-undo)
  (define-key winner-mode-map (kbd "<M-right>") #'winner-redo)
#+end_src
** Config

#+begin_src emacs-lisp
  (leader-keys
    "wq" 'delete-window
    "wo" 'delete-other-windows
    "w TAB" 'other-window
    "wr" 'evil-window-rotate-upwards
    "w/" 'evil-window-vsplit
    "wd" 'evil-window-split
    "wh" 'evil-window-left
    "wm" 'evil-window-left
    "wj" 'evil-window-down
    "wn" 'evil-window-down
    "wk" 'evil-window-up
    "we" 'evil-window-up
    "wl" 'evil-window-right
    "wi" 'evil-window-right
    "w=" 'balance-windows
    )
#+end_src
* In-file navigation
** Avy
#+begin_src emacs-lisp
  (use-package avy
    :custom (avy-all-windows nil))

  (leader-keys
    "sf" 'consult-line)

  (general-define-key
   :states '(normal visual)
   "s" 'avy-goto-char-2)
#+end_src
* Programming tools & Config
** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode)
    :config
    (setq flycheck-locate-config-file-functions '(flycheck-locate-config-file-ancestor-directories
                                                  flycheck-locate-config-file-by-path))
    (setq flycheck-check-syntax-automatically '(save
                                                ;; idle-change
                                                ;; new-line
                                                mode-enabled))
    (setq flycheck-display-errors-delay 0.3)
    (setq flycheck-flake8rc '(".flake8"))
    (setq flycheck-javascript-eslint-executable "eslint_d")

    (setq-default flycheck-temp-prefix ".flycheck")
    (setq-default flycheck-disabled-checkers
                  (append flycheck-disabled-checkers
                          '(javascript-jshint json-jsonlist)))

    (leader-keys
      "el" 'flycheck-list-errors
      "en" 'flycheck-next-error
      "ep" 'flycheck-previous-error)
    )

  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (flycheck-add-mode 'javascript-eslint 'js2-mode)
  (flycheck-add-mode 'javascript-eslint 'rjsx-mode)
  (flycheck-add-mode 'javascript-eslint 'typescript-mode)
  (flycheck-add-mode 'javascript-eslint 'typescript-tsx-mode)
#+end_src
** Flycheck posframe
#+begin_src emacs-lisp
  (use-package flycheck-posframe
    :after flycheck
    :config
    (setq flycheck-posframe-error-prefix "■ ")
    (setq flycheck-posframe-info-prefix "■ ")
    (setq flycheck-posframe-prefix "■ ")
    (setq flycheck-posframe-warning-prefix "■ ")

    (add-hook 'flycheck-mode-hook #'flycheck-posframe-mode))
#+end_src
** Eslintd
#+begin_src emacs-lisp
  (use-package eslintd-fix
    :hook ((web-mode
            typescript-mode
            typescript-tsx-mode
            css-mode
            scss-mode
            rjsx-mode
            json-mode) . eslintd-fix-mode))
#+end_src
** Code formatting AKA Prettier/Black/etc
Handled more often by eslintd when a project uses both eslint and prettier
#+begin_src emacs-lisp
  (use-package apheleia
    :hook ((web-mode
            typescript-mode
            typescript-tsx-mode
            css-mode
            scss-mode
            rjsx-mode
            vue-mode
            json-mode) . apheleia-mode)
    :config
    (apheleia-global-mode +1)
    (add-to-list 'apheleia-mode-alist '(typescript-tsx-mode prettier)))
#+end_src
** EditorConfig
#+begin_src emacs-lisp
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+end_src
** LSP Mode
#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :config
    (setq
          lsp-idle-delay 0.5
          lsp-auto-guess-root t
          lsp-restart 'auto-restart
          lsp-enable-completion-at-point t
          lsp-enable-symbol-highlighting t
          lsp-modeline-diagnostics-enable t
          lsp-diagnostic-package :none
          lsp-log-io nil ;; Don't log everything = speed
          lsp-lens-enable nil
          lsp-headerline-breadcrumb-enable nil
          lsp-signature-auto-activate nil
          lsp-modeline-code-actions-enable nil
          lsp-eslint-enable nil
          lsp-enable-on-type-formatting nil
          lsp-enable-folding nil
          lsp-enable-imenu nil
          lsp-enable-snippet nil
          )
    (setq read-process-output-max (* 1024 1024)) ;; 1mb
    (add-hook 'web-mode-hook #'lsp-flycheck-enable)
    (with-eval-after-load 'lsp-mode
      (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration))
    :custom
    (lsp-eldoc-render-all t)
    (lsp-enable-which-key-integration t)
    (lsp-rust-analyzer-cargo-watch-command "clippy")
    (lsp-rust-analyzer-server-display-inlay-hints t)
    )

  (use-package lsp-ui
    :commands lsp-ui-mode
    :bind (:map lsp-mode-map
                ("M-d" . xref-find-definitions)
                ("M-r" . xref-find-references)
                ("M-t" . lsp-find-type-definition)
                )
    :config
    (setq lsp-ui-doc-enable t
          lsp-ui-doc-use-childframe t
          lsp-ui-doc-position 'top
          lsp-ui-doc-include-signature t
          lsp-ui-sideline-enable nil
          lsp-ui-flycheck-enable t
          lsp-ui-flycheck-list-position 'right
          lsp-ui-flycheck-live-reporting t
          )
    (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
    (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
    :custom
    (lsp-ui-peek-enable t)
    (lsp-ui-peek-show-directory t)
    (lsp-ui-peek-list-width 60)
    (lsp-ui-peek-peek-height 25)
    (lsp-ui-peek-fontify 'on-demand)
    )

  (require 'lsp-diagnostics)
  (lsp-diagnostics-flycheck-enable)
#+end_src
** Web mode
#+begin_src emacs-lisp
  (use-package web-mode
    :defer 2
    :hook
    (web-mode . lsp-deferred)
    :mode (
       ("\\.html\\'" . web-mode))
    :commands web-mode)
#+end_src
** Emmet mode
#+begin_src emacs-lisp
  (use-package emmet-mode
    :hook (
           (typescript-tsx-mode . emmet-mode)
           (web-mode . emmet-mode)
           (css-mode . emmet-mode)
           (scss-mode . emmet-mode)
           ))

  (define-key evil-insert-state-map (kbd "C-,") 'emmet-expand-line)
#+end_src
** REPL
#+begin_src emacs-lisp
  (use-package nodejs-repl
    :config
    (leader-keys
     "rl" 'nodejs-repl-send-line
     "rr" 'nodejs-repl-send-region
     "rb" 'nodejs-repl-send-buffer
    ))
#+end_src
** RJSX mode
#+begin_src emacs-lisp
  (use-package rjsx-mode
    :hook
    (rjsx-mode . lsp-deferred)
    :mode (
           ("\\.js\\'" . rjsx-mode)
           ("\\.jsx\\'" .  rjsx-mode)
           ))
#+end_src
** Languages
*** Python
**** pyvenv + pipenv
#+begin_src emacs-lisp
  (setq pyvenv-virtualenvwrapper-python "python3")
  (setenv "WORKON_HOME" "~/.local/share/virtualenvs/")

  (use-package pyvenv
    :config
    (setq pyvenv-mode-line-indicator '(pyvenv-virtual-env-name ("[venv:" pyvenv-virtual-env-name "] ")))
    ;; Set correct Python interpreter
    (setq pyvenv-post-activate-hooks
          (list (lambda ()
                  (call-interactively #'lsp-workspace-restart)
                  (setq python-shell-interpreter (concat pyvenv-virtual-env "bin/python3")))))
    (setq pyvenv-post-deactivate-hooks
          (list (lambda ()
                  (setq python-shell-interpreter "python3"))))
    (pyvenv-mode +1))

  (use-package pipenv
    :hook (python-mode . pipenv-mode)
    :init
    (setq
     pipenv-projectile-after-switch-function
     #'pipenv-projectile-after-switch-extended))
#+end_src
**** pylint
#+begin_src emacs-lisp
  (use-package pylint)
#+end_src
**** LSP config
#+begin_src emacs-lisp
  (use-package lsp-python-ms
    :after (lsp-mode)
    :hook
    ((python-mode . (lambda ()
                      (require 'lsp-python-ms)
                      (lsp)
                      (flycheck-add-next-checker 'lsp 'python-flake8)
                      (flycheck-add-next-checker 'python-flake8 'python-pylint)
                      (message "Added flycheck checkers."))))
    :init
    (setq lsp-python-ms-auto-install-server t)
    ;; (setq lsp-python-ms-executable (executable-find "pyls"))
    )
#+end_src
*** Javascript/Typescript
#+begin_src emacs-lisp
  (setq js2-mode-show-parse-errors nil)
  (setq js2-mode-show-strict-warnings nil)

  (use-package typescript-mode
    :init
    (define-derived-mode typescript-tsx-mode typescript-mode "tsx")
    :config
    :mode ("\\.tsx?\\'" . typescript-tsx-mode)
    :hook ((typescript-tsx-mode . (lambda ()
                                    (lsp-deferred)
                                    ;; (flycheck-add-next-checker 'lsp 'javascript-eslint)
                                    ))))

  (use-package tree-sitter
    :hook ((typescript-mode . tree-sitter-hl-mode)
       (typescript-tsx-mode . tree-sitter-hl-mode)))

  (use-package tree-sitter-langs
    :after tree-sitter
    :config
    (tree-sitter-require 'tsx)
    (add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-mode . tsx))
    (add-to-list 'tree-sitter-major-mode-language-alist '(rustic-mode . rust)))
#+end_src
*** Vue
#+begin_src emacs-lisp
  (use-package vue-mode
    :straight (vue-mode :type git :host github :repo "AdamNiederer/vue-mode"))

  (use-package vue-mode
    :mode "\\.vue\\'"
    :config
    (add-hook 'vue-mode-hook #'lsp))
#+end_src
*** C#
#+begin_src emacs-lisp
  (use-package csharp-mode
    :hook ((csharp-mode . lsp-deferred))
    :config
    (add-to-list 'auto-mode-alist '("\\.cs\\'" . csharp-tree-sitter-mode)))

  (setq lsp-csharp-server-path "~/.emacs.d/.cache/lsp/omnisharp-roslyn/latest/run")
#+end_src
*** Lua
#+begin_src emacs-lisp
  (use-package lua-mode
    :config
    (setq lsp-lua-diagnostics-disable '("lowercase-global"))
    :hook ((lua-mode . (lambda ()
                         (lsp-deferred)))))
#+end_src
*** Rust
#+begin_src emacs-lisp
  (use-package rustic
    :bind (:map rustic-mode-map
                ("M-j" . lsp-ui-imenu))
    :config
    (setq rustic-lsp-server 'rust-analyzer)
    (setq rustic-format-on-save t))
#+end_src

* Transitioning from VIM to Emacs
Here is a list of stuff I set out to learn as I began using emacs
after using vim for three years

** Stuff I expect to be an editor
- Vim basics
  - Modal editing
  - Macros
  - surround.vim equivalent
  - sneak.vim equivalent
- File explorer
- File picker
- Autocomplete as I type
  - Variables and function
- Syntax highlighting
- Project-wide search (ag, rg, etc)
- Version control tooling

** Terminology / good to know
1) ~C-x C-c~ to quit emacs
2) ~M-x~ execute command
3) ~C-g~ to escape
4) ~C-h ?~ about help
5) ~C-h t~ opens the emacs tutorial
6) ~C-h k [key or series of keys]~ opens help about that key or string of keys
7) ~C-v~ minibuffer: scroll v one screen
8) ~M-v~ minibuffer: scroll ^ one screen
9) ~C-s~ start incremental search / go to next match
10) ~C-x 0~ kill current window

** Editor configuration
- Edit your init.el file
- ~M-x customize~

** Line navigation
1) marks equivalent
2) wellle/targets.vim equivalent
3) How to toggle comments

** File navigation
- File finder?

** Package manager
- ~M-x package-install RET~

** Code editing
1) emmet?
2) Intellisense / LSP capabilities?
   - Depends. There's stuff like lsp-mode and you can also use something like tide for javascript

** Visuals
1) statusline?
2) doom-modeline
3) icons?
4) Syntax highlighting
   * Colorscheme
5) Hex/RGBA/HSL color previews
6) Whichkey equivalent?
   - there's a vim package for this but this actually came from an emacs package

** How to close
- ~C-x C-c~
