* Intro
I'm writing this to answer questions I had when migrating to emacs in hopes of it being useful for others interested in doing the same

I've tried to break it down so that it's applicable to people coming from any editor

** But first ...
Some may want to skip to the [[#stuff-i-expect-from-an-editor]["Stuff I expect from an editor"]] section to get a sense of how some expectations can be met with emacs

What precedes that sets some context about emacs that can help understand how it all pieces together

** Second, my path to emacs
1. notepad++ / eclipse (during college and java 101)
2. sublime text (2014-2017)
3. webstorm (2017-2018)
4. vim/neovim (2018-2021)
5. emacs (2021+)
   * I tried out emacs out of curiosity after watching [[https://www.youtube.com/watch?v=JWD1Fpdd4Pc]["Evil Mode: Or, How I Learned to Stop Worrying and Love Emacs"]]
   * At this point I was in love with vim and I heard cool & intimidating things about emacs, so knowing that someone else made the switch eased the idea of doing it myself

* Terminology to know / helper intro tips
Before I walk through some equivalents from other editors, this context is useful when talking about emacs

~major-mode~ is closely equivalent to a filetype, you will have one activated at a time

~minor-mode~ is closely equivalent to a plugin, you will have multiple activated at a time

The key ~M-x~ means ~alt-x~ and is used to run the function ~execute-extended-command~ which enables you to run various commands, some native to emacs and some others provided from plugins that you install

You can run ~C-h f~ to learn about functions available. You'll see that each function has a bunch of helpful information on what it does, how it's written, and more
- Similarly ~C-h v~ will tell you about variables that are available to you
- And ~C-h k~ will wait for you to enter a keybinding then tell you what it runs

~C-x C-f~ can be used to open a file (runs the ~find-file~ function)

~C-s~ can be used to search in a file (runs the ~isearch-forward~ function)

~C-x C-c~ will close emacs, prompting you whether you want to save any changed files

Many menu lists in emacs can be navigated like so
- ~C-n~ / ~C-p~ can be used to go up or down one line at a time
- ~C-v~ / ~M-v~ can be used go whole pages down or up

~C-g~ can be used across emacs as the ~esc~ key in other programs

* Package manager
Plugins can be installed with the default ~package-install~ command (accessed with ~M-x~)

Alternatively, I like using the [[https://github.com/jwiegley/use-package][use-package]] package for managing the installing of plugins and managing their configurations, here's an example of installing a snippet plugin and adding some configurations
#+begin_src emacs-lisp

  (use-package yasnippet
    :bind (:map evil-insert-state-map
                ("C-y" . yas-expand))
    :config
    (yas-global-mode 1)
    (setq yas-snippet-dirs '("~/.emacs.d/snippets")))

#+end_src

* Stuff I expect from an editor
Here it is. When considering a new editor, you want to know how to do some basic things

** 1. File explorer
Most editors have a tree-like view of files

Here we have a few options, the ones that stand out at first are:
- [[https://github.com/jaypei/emacs-neotree][Neotree]]: Simple, reminds me of NERDTree from vim
- [[https://github.com/Alexander-Miller/treemacs#treemacs---a-tree-layout-file-explorer-for-emacs][Treemacs]]: It's also compared with NERDTree but feels .. fancier?

This is what I was used to and wanted, so I started with the above

But actually a simpler directory view turns out to be more powerful, in my experience

That solution is called [[https://www.emacswiki.org/emacs/DiredMode][dired]] and I highly recommend trying it out
- This is similar to vim's [[https://www.vim.org/scripts/script.php?script_id=1075][netrw]] or [[https://github.com/tpope/vim-vinegar][vinegar]]

In the beginning I was skeptical of something like dired as I got used to editing and viewing files with a tree-like view but in time I've changed to love the dired approach

Although, when you're getting acquainted with a new project I find it's very useful to have the tree-like view

** 2. File picker
Searching for a file is typically done with a fuzzy finder

The answer is the [[https://github.com/bbatsov/projectile][projectile]] package which provides a variety of project-related functions. One of which is project search!

With the ~projectile-find-file~ command you're given a list of all files in the project and you can filter the list as you type

*** The built in approach
Alternatively, you can use emacs's ~find-file~ command for similar functionality. It's just that to search in sub-folders it requires you tab-complete, which slows down finding your desired file

** 3. Autocomplete as I type
In my opinion, any editor worth it's salt can provide suggestions as you type

Here I find [[https://company-mode.github.io/][company]] to be indispensable as it plugs in with various tools for completion--most notable for suggesting variables/functions, which we'll cover later

*** Fun fact
Some people actually don't like having suggestions happen by default :shrug: To each their own

** 4. Project-wide search ~(ag, rg, etc)~
Searching for specific text within a project can be achieved with programs like grep and similar

I've settled on using [[https://github.com/Wilfred/deadgrep][deadgrep]] which provides a nice list of results that you can visit individually after searching

** 5. Version control
I use [[https://git-scm.com/][git]] for version control

It's most often interacted with via the command line with commands like ~git add~, ~git status~, etc

Some users use a GUI tool instead, and in vim land I know many use [[https://github.com/tpope/vim-fugitive][vim-fugitive]]

When I was using vim, I used [[https://github.com/jesseduffield/lazygit][lazygit]] in a separate terminal window to great effect

In emacs we have [[https://magit.vc/][magit]]. I think you'll agree after using it that it's a game changer

Simply searching for it on youtube provides bountiful tutorials on its usage: [[https://www.youtube.com/results?search_query=magit][see here]]
** 6. Visuals
*** Color schemes
As with all editors, there's a bountiful list of color schemes to choose from

I like to use ~gruvbox~ which I access via [[https://github.com/doomemacs/themes][doomemacs/themes]]

*** Syntax highlighting
This comes out of the box with a language's ~major-mode~ and it's achieved with regular expressions. It ties in with your colorscheme to provide the precise coloring

**** Fun fact
[[https://tree-sitter.github.io/tree-sitter/][Treesitter]] is a recent change in how this is done, and some colorschemes have support for it. Mostly it's a nice to have and as time goes on more colorschemes have support for it

** 7. Code editing
Most editors have some of what's called "intellisense" for suggesting variable/function names, properties on classes/objects as you type, and we have that in emacs too

Traditionally, editors relied on the generation of "tags" to index a codebase and enable such suggestions

After having a tags file, editors would provide functionality to hook into that but it was very different per language

More recently, [[https://langserver.org/][language servers]] came onto the scene, enabling a uniform API for implementing such actions regardless of the language

Back to ~company~, the [[https://github.com/emacs-lsp/lsp-mode/][lsp-mode]] package can hook into ~company~ to provide intelligent, code aware suggestions as you type
** 8. Editor configuration
Your configuration is done via ~init.el~ and it's all written in ~elisp~, like this:

#+begin_src emacs-lisp
(message "Hello, World!")
#+end_src

If you haven't seen lisp before, this is how you run a function

You can use ~M-x customize~ to interactively change settings, all of which will get saved to ~init.el~

I try to not edit ~init.el~ directly since it's often updated interactively. Instead, I write my configurations to ~my-org-init.org~

This ~init.el~ line is what enables me to do that:

#+begin_src emacs-lisp
(require 'org)
(org-babel-load-file
 (expand-file-name "~/dotfiles/emacs/my-org-init.org"))
#+end_src

It converts the org file into a ~.el~ file (learn more about org-mode [[https://orgmode.org/][here]])
** 10. Icons
Everyone likes icons! Emacs users included ;-)

There's a variety of packages that introduce some icons here or there

A few that I use add icons to ~company~'s completions, ~dired~, and the tree-like file viewers
** 11. Vim emulation
Many programs offer keyboard navigation that was inspired by vim, like Gmail's ~j/k~ shortcuts for moving down or up

Similarly, many text editors/IDEs offer something similar for file navigation, each with varying levels of implementation

The answer is EVIL mode: https://www.emacswiki.org/emacs/Evil

I would wager that EVIL mode is as close to a complete implementation of vim keybindings that exist anywhere--outside of vim itself, that is

*** surround.vim equivalent
The ability to easily wrap things in quotes/parentheses/brackets

See: [[https://github.com/emacs-evil/evil-surround][evil-surround]]

*** sneak.vim equivalent
The ability to quickly navigate to any text you see

See: [[https://github.com/abo-abo/avy][avy]]

Similar to [[https://github.com/justinmk/vim-sneak][sneak]] or [[https://github.com/easymotion/vim-easymotion][easymotion]], I've bound ~s~ to ~evil-avy-goto-char-2~
* Emacs specific stuff
*** Modeline
Every text editor/IDE has some ancillary information around the user interface

In emacs that's the [[https://www.emacswiki.org/emacs/ModeLine][modeline]], in vim that is the [[https://vim.fandom.com/wiki/Status_line_to_display_more_information][statusline]], each by default at the bottom of the screen. This provides info on the current file being viewed, how far in a file you've scrolled, some version control information (like which git branch you're on), etc

You can install packages like [[https://github.com/seagle0128/doom-modeline][doom-modeline]] (packaged separately from [[https://github.com/doomemacs/doomemacs][Doom Emacs]]) for some nice visual modifications out of the box

I went down the rabbithole of customizing my own but in the end have settled for using the default one
- The one exception is using [[https://github.com/tarsius/minions][minions]] for condensing the list of active packages to just ~;-~ which in an org file shows up as ~(Org ;-)~ which looks like a winky face haha
*** Whichkey
Man. I remember while I was still using vim and I saw this emacs package called [[https://github.com/justbur/emacs-which-key][whichkey]] and I knew I *needed* to have it

When you begin a keybinding and pause before pressing the next key, ~whichkey~ will show you what key to press next to get a particular functionality

Additionally, you can run the ~which-key-show-keymap~ command on its own to reveal all the available keybindings for whichever mode you're in
