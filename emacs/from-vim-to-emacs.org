* Intro
I'm writing this to answer questions I had when migrating to emacs in hopes of it being useful for others interested in doing the same

I've tried to break it down so that it's applicable to people coming from any editor

** But first ...
Some may want to skip to the [[#stuff-i-expect-from-an-editor]["Stuff I expect from an editor"]] section to get a sense of how some expectations can be met with emacs

What precedes that sets some context about emacs that can help understand how it all pieces together

** Second, my path to emacs
Before Emacs, I had been using vim for about 3 years, here's my editor progression

1. notepad++ / eclipse (during college and java 101)
2. sublime text (2014-2017)
3. webstorm (2017-2018)
4. vim/neovim (2018-2021)
5. emacs (2021+)

I first saw [[https://www.youtube.com/watch?v=JWD1Fpdd4Pc]["Evil Mode: Or, How I Learned to Stop Worrying and Love Emacs"]] maybe around 2019

When I watched that video I was perfectly comfortable with vim and was pretty happy with the state of my setup, but it definitely got my attention and I used it as a resource when I decided to take an actual look at emacs and how it would serve my workflow as a programmer

* Terminology to know / helper intro tips
Before I walk through some equivalents from other editors, this context is useful when talking about emacs

~major-mode~ is closely equivalent to a filetype, you will have one activated at a time

~minor-mode~ is closely equivalent to a plugin, you will have multiple activated at a time

The key ~M-x~ means ~alt-x~ and is used to run the function ~execute-extended-command~ which enables you to run various commands, some native to emacs and some others provided from plugins that you install

You can run ~C-h f~ to learn about functions available. You'll see that each function has a bunch of helpful information on what it does, how it's written, and more
- Similarly ~C-h v~ will tell you about variables that are available to you
- And ~C-h k~ will wait for you to enter a keybinding then tell you what it runs

~C-x C-f~ can be used to open a file (runs the ~find-file~ function)

~C-s~ can be used to search in a file (runs the ~isearch-forward~ function)

~C-x C-c~ will close emacs, prompting you whether you want to save any changed files

Many menu lists in emacs can be navigated like so
- ~C-n~ / ~C-p~ can be used to go up or down one line at a time
- ~C-v~ / ~M-v~ can be used go whole pages down or up

~C-g~ can be used across emacs as the ~esc~ key in other programs

* Stuff I expect from an editor
Here it is. When considering a new editor, you want to know how to do some basic things

** First, a package manager
There's a lot emacs can do without plugins, but I refer to a few throughout this doc so I'll lead with this

Plugins can be installed with the built-in ~package-install~ command (accessed with ~M-x~)
- It looks at a few websites that host the plugins for that plugin, this can be customized later

I like using the [[https://github.com/jwiegley/use-package][use-package]] package for describing what plugins I have installed

Here's an example of how you can install and configure a snippet plugin
#+begin_src emacs-lisp

  (use-package yasnippet
    :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets")))

#+end_src

** 1. File explorer
Most editors have a tree-like view of files

Here we have a few options, the ones that stand out at first are:
- [[https://github.com/jaypei/emacs-neotree][Neotree]]: Simple, reminds me of NERDTree from vim
- [[https://github.com/Alexander-Miller/treemacs#treemacs---a-tree-layout-file-explorer-for-emacs][Treemacs]]: Compared with NERDTree and inspired by Eclipse's file tree

When I switched to emacs I had only ever used tree-like viewers

But a simpler directory view turns out to be pretty powerful too

That would be [[https://www.emacswiki.org/emacs/DiredMode][dired]] and I highly recommend trying it out
- It's similar to vim's [[https://www.vim.org/scripts/script.php?script_id=1075][netrw]] or [[https://github.com/tpope/vim-vinegar][vinegar]]

In the beginning I was skeptical of something like ~dired~ but in time I've changed to love the dired approach

Although, when you're getting acquainted with a new project I find it's very useful to have the tree-like view

** 2. File picker
Searching for a file is typically done with a fuzzy finder

The answer is the [[https://github.com/bbatsov/projectile][projectile]] package which provides a variety of project-related functions. One of which is project search!

With the ~projectile-find-file~ command you're given a list of all files in the project and you can filter the list as you type

Alternatively, you can use emacs's ~find-file~ command for similar functionality. It's just that to search in sub-folders it requires you tab-complete, which slows down finding your desired file

** 3. Autocomplete as I type
In my opinion, any editor worth it's salt can provide suggestions as you type

Here I find [[https://company-mode.github.io/][company]] to be indispensable as it plugs in with various tools for completion. Most notable is its usage for suggesting variables/functions, which we'll cover later

*** Fun fact
Some people actually don't like having suggestions happen by default :shrug: To each their own

** 4. Project-wide search ~(grep, rg, ack, ag, etc)~
Searching for specific text within a project can be achieved with programs like grep and similar

I've settled on using [[https://github.com/Wilfred/deadgrep][deadgrep]] which provides a nice list of results that you can visit individually after searching

** 5. Version control
[[https://magit.vc/][Magit]] is the go-to tool for git. You run ~magit-status~ and can stage/commit/merge/push/pull all within it with minimal keystrokes

Outside of emacs some use the command line, some use [[https://github.com/jesseduffield/lazygit][lazygit]], some use [[https://github.com/tpope/vim-fugitive][vim-fugitive]], and some use a visual GUI for interacting with git

Out of everything I tried, I first thought lazygit was the end-all-be-all git tool. But after using magit I feel it really takes the cake for that title

*** Note
I know some prefer seeing which lines in a file were edited

And there are plugins that support that, I just happen to not use those

** 6. Visuals
*** Color schemes
As with all editors, there's a bountiful list of color schemes to choose from

I like to use ~gruvbox~ which I access via [[https://github.com/doomemacs/themes][doomemacs/themes]]

*** Syntax highlighting
This comes out of the box with a ~major-mode~ (think ~python-mode~)

**** Fun fact
Traditionally keywords for a language are identified with regular expression, which color schemes use for coloring

New to the scene here is [[https://tree-sitter.github.io/tree-sitter/][Treesitter]] which is capable of generating syntax trees for a language, quickly and on the fly

There are a number of colorschemes that support coloring via treesitter, which you may find to provide a peformance boost in analyzing files

** 7. Code editing
Most editors have some of what's called "intellisense" for suggesting variable/function names, properties on classes/objects as you type

Emacs has a package called [[https://github.com/emacs-lsp/lsp-mode/][lsp-mode]] which provides this, and ~company~ can integrate with it to provide intelligent, code-aware suggestions as you type
- This uses the language server protocol and has support for most languages

Traditionally, editors relied on the generation of "tags" for some languages to index a codebase and enable such suggestions

More recently, [[https://langserver.org/][language servers]] came onto the scene, enabling a uniform API for implementing such actions regardless of the language

** 8. Editor configuration
Your configuration is done via ~init.el~ and it's all written in ~elisp~, like this:

#+begin_src emacs-lisp
(message "Hello, World!")
#+end_src

If you haven't seen lisp before, this is how you run a function

You can use ~M-x customize~ to interactively change settings, all of which will get saved to ~init.el~

I try to not edit ~init.el~ directly since it's often updated interactively. Instead, I write my configurations to ~my-org-init.org~

These lines in ~init.el~ are what enables me to do that:

#+begin_src emacs-lisp
(require 'org)
(org-babel-load-file
 (expand-file-name "~/dotfiles/emacs/my-org-init.org"))
#+end_src

It converts the org file into a ~.el~ file (learn more about org-mode [[https://orgmode.org/][here]])
** 10. Icons
Everyone likes icons! Emacs users included ;-)

There's a variety of packages that introduce some icons here or there

A few that I use add icons to ~company~'s completions, ~dired~, and the tree-like file viewers
** 11. Vim emulation
Many programs offer keyboard navigation that was inspired by vim, like Gmail's ~j/k~ shortcuts for moving down or up

Similarly, many text editors/IDEs offer something similar for file navigation, each with varying levels of implementation

The answer is EVIL mode: https://www.emacswiki.org/emacs/Evil

I would wager that EVIL mode is as close to a complete implementation of vim keybindings that exist anywhere--outside of vim itself, that is

*** surround.vim equivalent
The ability to easily wrap things in quotes/parentheses/brackets

See: [[https://github.com/emacs-evil/evil-surround][evil-surround]]

*** sneak.vim equivalent
The ability to quickly navigate to any text you see

See: [[https://github.com/abo-abo/avy][avy]]

Similar to [[https://github.com/justinmk/vim-sneak][sneak]] or [[https://github.com/easymotion/vim-easymotion][easymotion]], I've bound ~s~ to ~evil-avy-goto-char-2~
* Emacs specific stuff
*** Modeline
Every text editor/IDE has some ancillary information around the user interface

In emacs that's the [[https://www.emacswiki.org/emacs/ModeLine][modeline]], in vim that is the [[https://vim.fandom.com/wiki/Status_line_to_display_more_information][statusline]], each by default at the bottom of the screen. This provides info on the current file being viewed, how far in a file you've scrolled, some version control information (like which git branch you're on), etc

You can install packages like [[https://github.com/seagle0128/doom-modeline][doom-modeline]] (packaged separately from [[https://github.com/doomemacs/doomemacs][Doom Emacs]]) for some nice visual modifications out of the box

I went down the rabbithole of customizing my own but in the end have settled for using the default one
- The one exception is using [[https://github.com/tarsius/minions][minions]] for condensing the list of active packages to just ~;-~ which in an org file shows up as ~(Org ;-)~ which looks like a winky face haha
*** Whichkey
Man. I remember while I was still using vim and I saw this emacs package called [[https://github.com/justbur/emacs-which-key][whichkey]] and I knew I *needed* to have it

When you begin a keybinding and pause before pressing the next key, ~whichkey~ will show you what key to press next to get a particular functionality

Additionally, you can run the ~which-key-show-keymap~ command on its own to reveal all the available keybindings for whichever mode you're in
