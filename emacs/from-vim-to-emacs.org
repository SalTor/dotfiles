* Intro
I'm writing this to answer questions I had when migrating to emacs in hopes of it being useful for others interested in doing the same

I've tried to break it down so that it's applicable to people coming from any editor

** *My* path to emacs
1. notepad++ / ecplipse (during college and java 101)
2. sublime text (2014-2017)
3. webstorm (2017-2018)
4. vim/neovim (2018-2021)
   * When I switched to vim, it was revolutionary for me and I spent a lot of time configuring it learning the ins and outs of helpful keybindings
5. emacs (2021+)

* Terminology to know / helper intro tips
~major-mode~ is closely equivalent to a filetype, you will have one activated at a time

~minor-mode~ is closely equivalent to a plugin, you will have multiple activated at a time

The key ~M-x~ means ~alt-x~ and is used to run the function ~execute-extended-command~ which enables you to run various commands, some native to emacs and some others provided from plugins that you install

You can run ~C-h f~ to learn about functions available. You'll see that each function has a bunch of helpful information on what it does, how it's written, and more
- Similarly ~C-h v~ will tell you about variables that are available to you
- And ~C-h k~ will wait for you to enter a keybinding then tell you what it runs

~C-x C-f~ can be used to open a file (runs the ~find-file~ function)

~C-s~ can be used to search in a file (runs the ~isearch-forward~ function)

~C-x C-c~ will close emacs, prompting you whether you want to save any changed files

Many menu lists in emacs can be navigated like so
- ~C-n~ / ~C-p~ can be used to go up or down one line at a time
- ~C-v~ / ~M-v~ can be used go whole pages down or up

~C-g~ can be used across emacs as the ~esc~ key in other programs

* Package manager
Plugins can be installed with the default ~package-install~ command (accessed with ~M-x~)

Alternatively, I like using the [[https://github.com/jwiegley/use-package][use-package]] package for managing the installing of plugins and managing their configurations, here's an example of installing a snippet plugin and adding some configurations
#+begin_src emacs-lisp

  (use-package yasnippet
    :bind (:map evil-insert-state-map
                ("C-y" . yas-expand))
    :config
    (yas-global-mode 1)
    (setq yas-snippet-dirs '("~/.emacs.d/snippets")))

#+end_src

* Stuff I expect from an editor
** File explorer
Most editors have a tree-like view of files.

Here we have a few options, the ones that stand out at first are:
- [[https://github.com/jaypei/emacs-neotree][Neotree]]: Simple, reminds me of NERDTree from vim
- [[https://github.com/Alexander-Miller/treemacs#treemacs---a-tree-layout-file-explorer-for-emacs][Treemacs]]: It's also compared with NERDTree but feels .. fancier?

For a simpler directory view, similar to ~ls~:
- [[https://www.emacswiki.org/emacs/DiredMode][dired]] (directory editor)
  - This is similar to vim's [[https://www.vim.org/scripts/script.php?script_id=1075][netrw]] (often paired with [[https://github.com/tpope/vim-vinegar][vinegar]])

In the beginning I was skeptical of something like dired as I got used to editing and viewing files with a tree-like view

In time I've changed to love the dired approach. Although, I find a tree-like view to be better for getting acquainted with a new project, so I have both kinds installed but I use dired day-to-day
** File picker
Often it's preferable to open a prompt and type to search for a file.

There is the built-in ~find-file~ command which is decent, but to search in sub-folders it requires you tab-complete, which slows file search down--but it does offer more precise search!

I think the go-to here is to [[https://github.com/bbatsov/projectile][projectile]] which is "Project Interaction Library for Emacs"

I use the ~projectile-find-file~ command for finding files
** Autocomplete as I type
Emacs has built-in ~completion-at-point~ functionaliy
I find [[https://company-mode.github.io/][company]] to be indispensable as it plugs in with various tools for completion like with various programming tools
** Project-wide search ~(ag, rg, etc)~
Searching for specific text within a project can be achieved with programs like grep and similar.

I've settled on using [[https://github.com/Wilfred/deadgrep][deadgrep]] which provides a nice list of results that you can visit individually after searching.
** Version control
I use [[https://git-scm.com/][git]] for version control, and it's most often interacted with via the command line with commands like ~git add~, ~git status~, etc. Some users use a GUI tool instead.

In vim land I know many use [[https://github.com/tpope/vim-fugitive][vim-fugitive]] and swear by it.

Personally, I used [[https://github.com/jesseduffield/lazygit][lazygit]] in a separate terminal window to great effect and felt it was a game changer.

However, in emacs we have [[https://magit.vc/][magit]] which, too, is a game changer.
** Syntax highlighting
Traditionally, text editors/IDEs used regular expressions per language type to highlight different syntaxes. And most language plugins (minor modes) for emacs provide this.

More recently, [[https://tree-sitter.github.io/tree-sitter/][treesitter]] came onto the scene which is a better approach to identifying languag syntaxes.

Between the two approaches, treesitter has fewer color scheme support for syntax highlighting--but this is changing with time.
** Vim emulation
The answer is EVIL mode: https://www.emacswiki.org/emacs/Evil

Many programs offer keyboard navigation that was inspired by vim, like Gmail's ~j/k~ shortcuts for moving down or up

Similarly, many text editors/IDEs offer something similar for file navigation, each with varying levels of implementation.

I would wager that EVIL mode is as close to a complete implementation of vim keybindings that exist anywhere--outside of vim itself, that is.

*** surround.vim equivalent
The ability to easily wrap things in quotes/parentheses/brackets

See: [[https://github.com/emacs-evil/evil-surround][evil-surround]]

*** sneak.vim equivalent
The ability to quickly navigate to any text you see

See: [[https://github.com/abo-abo/avy][avy]]

Similar to [[https://github.com/justinmk/vim-sneak][sneak]] or [[https://github.com/easymotion/vim-easymotion][easymotion]], I've bound ~s~ to ~evil-avy-goto-char-2~

* Editor configuration
Your configuration it done via =init.el= and it's all written in =elisp=, like this:
#+begin_src emacs-lisp
(message "Hello, World!")
#+end_src
If you haven't seen lisp before, there's a lot of parentheses and this is how you run a function
You can use ~M-x customize~ to interactively set a variety of settings, all of which will get saved to ~init.el~
I try to not edit ~init.el~ directly since it's often updated interactively and instead write my configurations to ~my-org-init.org~ and I have this line at the start of my ~init.el~ which at startup converts my org file to a ~.el~ file so that emacs can use it for configuration while allowing me to document some notes in a markdown-esque format with plain text as well as code blocks
#+begin_src emacs-lisp
(require 'org)
(org-babel-load-file
 (expand-file-name "~/dotfiles/emacs/my-org-init.org"))
#+end_src
On the topic of ~org-mode~ .. you can learn more about it [[https://orgmode.org/][here]] (be warned, it's game a game changer)

* Code editing
We briefly went over ~company~ for some integration of smart autocomplete, and that's particularly useful for programming

Most editors have some of what's called "intellisense" for suggesting variable/function names, properties on classes/objects as you type

Traditionally, editors relied on proprietary tools that enabled this sort of thing or relied on the generation of "tag files" to index a codebase and enable such suggestions

Then editors would provide functionality to hook into those solutions but it was very different per language. For example, renaming a variable would have to have been implemented very differently per language and each editor would have to sort out how they'd enable the user to do those actions

More recently, [[https://langserver.org/][language servers]] came onto the scene, enabling a uniform API for implementing such actions regardless of the language; as long as there was a language server running for that language, the langserver API could be used to instruct the server what they wanted to do. This enables each editor to have a uniform API for code editing actions. Want to rename a variable? Check to see if there's a language server for that language running, then send ~some_fn_call()~ to said language server and wait for the result

And to connect this back to ~company~, the [[https://github.com/emacs-lsp/lsp-mode/][lsp-mode]] package can hook into ~company~ to provide intelligent, code aware suggestions as you type

* Visuals
** Modeline
Every text editor/IDE has some ancillary information around the user interface

In emacs that's the [[https://www.emacswiki.org/emacs/ModeLine][modeline]], in vim that is the [[https://vim.fandom.com/wiki/Status_line_to_display_more_information][statusline]], each by default at the bottom of the screen. This provides info on the current file being viewed, how far in a file you've scrolled, some version control information (like which git branch you're on), etc.

You can install packages like [[https://github.com/seagle0128/doom-modeline][doom-modeline]] (packaged separately from [[https://github.com/doomemacs/doomemacs][Doom Emacs]]) for some nice visual modifications out of the box

I went down the rabbithole of customizing my own but in the end have settled for using the default one
- The one exception is using [[https://github.com/tarsius/minions][minions]] for condensing the list of active packages to just ~;-~ which in an org file shows up as ~(Org ;-)~ which looks like a winky face haha
** Icons
There's a variety of packages that introduce some icons here or there

A few that I use add icons to ~company~'s completions, ~dired~, and the tree-like file viewers
** Color schemes
As with all editors, there's a bountiful list of color schemes to choose from

I keep an eye out for ones that support using treesitter for their coloring as that often provides more legible coloring of keywords

I like to use ~gruvbox~ which I access via [[https://github.com/doomemacs/themes][doomemacs/themes]]
** Whichkey
Man. I remember while I was still using vim and I saw this emacs package called [[https://github.com/justbur/emacs-which-key][whichkey]] and I knew I *needed* to have it

When you begin a keybinding and pause before pressing the next key, ~whichkey~ will show you what key to press next to get a particular functionality

Additionally, you can run the ~which-key-show-keymap~ command on its own to reveal all the available keybindings for whichever mode you're in
